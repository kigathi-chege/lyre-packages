#!/usr/bin/env bash
set -euo pipefail

#############################################
# Globals
#############################################
DRY_RUN=false
SHOW_HELP=false
ARGS=()
MONOREPO_DEFAULT_BRANCH=main
LIST_SUBMODULES=false

#############################################
# Parse flags
#############################################
while [[ $# -gt 0 ]]; do
  case "$1" in
    -n|--dry-run)
      DRY_RUN=true
      shift
      ;;
    -h|--help)
      SHOW_HELP=true
      shift
      ;;
    -l|--list)
      LIST_SUBMODULES=true
      shift
      ;;
    *)
      ARGS+=("$1")
      shift
      ;;
  esac
done

if $LIST_SUBMODULES; then
  echo "üì¶ Submodules in this monorepo:"
  git submodule status --recursive | awk '{print $2}' | awk -F/ '{print $2}' | sort
  exit 0
fi

#############################################
# Help
#############################################
if [[ "$SHOW_HELP" == true ]]; then
  cat <<'EOF'
release ‚Äî multi-package release CLI for Lyre monorepo

USAGE:
  release [options] <spec> [<spec>...]

OPTIONS:
  -n, --dry-run    Preview actions, do not execute any git or publish changes
  -h, --help       Show this help message

SPECS:
  A "spec" defines which package(s) to release, optionally with a version and commit message.

  Single package (auto version detection):
    content

  Single package with explicit version:
    content 1.4.0

  Single package with explicit version and commit message:
    content 1.4.0 "feat(content): add new feature"

  Key-value style:
    content:version=1.4.0,message="feat(content): add new feature"
    lyre:version=2.0.0,message="breaking change"

  Special keywords:
    all       Release all packages
    changed   Release only packages with unpushed commits or staged changes
    auto      Release only packages with detected changes since the latest tag
    since <git-ref>  Release packages changed since a Git reference, e.g., main

NOTES:
- Can be run from **any directory** inside the monorepo
- Works with Git submodules
- Invokes publish.sh for each released package
- Safe to use with `--dry-run` to preview actions
- Auto-detects semantic version bumps:
    - Commit messages containing "breaking" ‚Üí major
    - Commit messages containing "feat" ‚Üí minor
    - Other changes ‚Üí patch

EXAMPLES:

# Release a single package with auto-detected version
release content

# Release multiple packages
release content file

# Release with explicit version
release content 1.4.0

# Release with explicit version and custom commit message
release content 1.4.0 "feat(content): add new feature"

# Key-value style release
release content:version=1.4.0,message="feat(content): add new feature"

# Dry-run preview without pushing or publishing
release -n content 1.4.0 "feat(content): test dry run"

# Release all changed packages automatically
release auto

# Release all packages regardless of changes
release all

# Release packages changed since a Git ref
release since main

EOF
  exit 0
fi


command -v jq >/dev/null || {
  echo "‚ùå jq is required to update composer.json"
  exit 1
}

log() {
  printf "üîç [%s] %s\n" "$(date '+%H:%M:%S')" "$*" >&2
}


#############################################
# Repo root
#############################################
REPO_ROOT=$(git rev-parse --show-toplevel 2>/dev/null || true)
[[ -z "$REPO_ROOT" ]] && { echo "‚ùå Not in a git repo"; exit 1; }
cd "$REPO_ROOT"

[[ -x ./publish.sh ]] || {
  echo "‚ùå publish.sh not found or not executable"
  exit 1
}

#############################################
# Helper
#############################################
is_dry_run() { [[ "$DRY_RUN" == true ]]; }

run() {
  if is_dry_run; then
    echo "üü° DRY-RUN: $*"
  else
    "$@"
  fi
}

#############################################
# Discover packages
#############################################
discover_all_packages() {
  git submodule status --recursive | awk '{print $2}' | awk -F/ '{print $2}'
}

discover_changed_packages() {
  git submodule status --recursive | awk '$1 ~ /^[+-]/ {print $2}' | awk -F/ '{print $2}'
}

discover_since_packages() {
  local ref="$1"
  git diff --name-only "$ref"...HEAD | grep '^packages/' | awk -F/ '{print $2}' | sort -u
}

log "ARGS before keyword expansion: (${#ARGS[@]}) ${ARGS[*]}"
if [[ "${ARGS[0]:-}" == "all" ]]; then
  mapfile -t ARGS < <(discover_all_packages)
elif [[ "${ARGS[0]:-}" == "changed" ]]; then
  mapfile -t ARGS < <(discover_changed_packages)
elif [[ "${ARGS[0]:-}" == "since" ]]; then
  [[ -z "${ARGS[1]:-}" ]] && { echo "‚ùå since requires a git ref"; exit 1; }
  mapfile -t ARGS < <(discover_since_packages "${ARGS[1]}")
fi

log "ARGS after keyword expansion: (${#ARGS[@]})"
for a in "${ARGS[@]}"; do
  log "  ARG: [$a]"
done

AUTO_REQUESTED=false
[[ "${ARGS[0]:-}" == "auto" ]] && AUTO_REQUESTED=true

if $AUTO_REQUESTED && [[ ${#ARGS[@]} -gt 1 ]]; then
  echo "‚ùå 'auto' cannot be combined with other specs"
  exit 1
fi

if $AUTO_REQUESTED; then
  AUTO_MODE=true
  ARGS=($(discover_changed_packages))
else
  AUTO_MODE=false
fi

log "RAW ARGS COUNT: $#"
log "PARSED ARGS (${#ARGS[@]}):"
for a in "${ARGS[@]}"; do
  log "  ARG: [$a]"
done

#############################################
# Version utilities
#############################################
latest_tag() {
  git describe --tags --abbrev=0 2>/dev/null || echo "0.0.0"
}

bump_version() {
  local v="$1" type="$2"
  IFS=. read -r major minor patch <<< "${v#v}"

  case "$type" in
    major) ((major++)); minor=0; patch=0 ;;
    minor) ((minor++)); patch=0 ;;
    patch) ((patch++)) ;;
  esac

  echo "$major.$minor.$patch"
}

detect_bump() {
  git log --oneline "$(latest_tag)"..HEAD | grep -qi breaking && echo major && return
  git log --oneline "$(latest_tag)"..HEAD | grep -qi feat && echo minor && return
  echo patch
}

is_version() {
  [[ "$1" =~ ^v?[0-9]+\.[0-9]+\.[0-9]+ ]]
}

#############################################
# Parse specs
# Fully bulletproof parser
# Rules:
# - Packages are unquoted
# - Versions are optional semantic versions (x.y.z)
# - Commit messages must be quoted if they contain spaces/colons
# - Key-value style: pkg:version=1.2.3,message="feat: ..."

parse_specs() {
  local specs=("$@")
  local i=0
  local n=${#specs[@]}

  log "parse_specs called with $n tokens"
  for s in "${specs[@]}"; do
    log "  SPEC TOKEN: [$s]"
  done

  while [[ $i -lt $n ]]; do
    local token="${specs[$i]}"
    local PKG=""
    local VERSION=""
    local MESSAGE=""

    log "parse_specs loop i=$i token=[$token]"

    if [[ "$token" == *":"* && "$token" == *"="* ]]; then
      PKG="${token%%:*}"
      log "Detected key-value spec for package [$PKG]"

      IFS=',' read -ra KV <<< "${token#*:}"
      for pair in "${KV[@]}"; do
        log "  KV pair: [$pair]"
        case "$pair" in
          version=*) VERSION="${pair#version=}" ;;
          v=*)       VERSION="${pair#v=}" ;;
          message=*) MESSAGE="${pair#message=}" ;;
          m=*)       MESSAGE="${pair#m=}" ;;
        esac
      done
      ((++i))
    else
      PKG="$token"
      ((++i))
      log "Detected package [$PKG]"

      if [[ $i -lt $n ]] && is_version "${specs[$i]}"; then
        VERSION="${specs[$i]}"
        log "Detected version [$VERSION]"
        ((++i))
      fi

      if [[ $i -lt $n ]]; then
        local next="${specs[$i]}"
        log "Inspecting possible message token [$next]"
        if [[ ! "$next" =~ ^[a-zA-Z0-9_-]+$ ]]; then
          MESSAGE="$next"
          log "Detected commit message [$MESSAGE]"
          ((++i))
        fi
      fi
    fi

    log "EMIT TASK: PKG=[$PKG] VERSION=[$VERSION] MESSAGE=[$MESSAGE]"
    echo "$PKG|$VERSION|$MESSAGE"
  done
}


#############################################
# Execute releases
#############################################
mapfile -t TASKS < <(parse_specs "${ARGS[@]}")

log "TASKS COUNT: ${#TASKS[@]}"
for t in "${TASKS[@]}"; do
  log "TASK: [$t]"
done


[[ ${#TASKS[@]} -eq 0 ]] && {
  echo "‚ÑπÔ∏è  Nothing to release"
  exit 0
}

UPDATED_SUBMODULES=()

# Array to hold packages and versions for final publish
declare -A TO_PUBLISH=()

for task in "${TASKS[@]}"; do
  IFS='|' read -r PKG VERSION MESSAGE <<< "$task"
  PKG_PATH="packages/$PKG"

  if [[ ! -d "$PKG_PATH/.git" && ! -f "$PKG_PATH/.git" ]]; then
    echo "‚ùå $PKG is not a submodule"
    exit 1
  fi

  # Initialize submodule if needed
  git submodule update --init "$PKG_PATH"

  echo ""
  echo "========================================"
  echo "üì¶ $(date '+%Y-%m-%d %H:%M:%S') Releasing $PKG"
  echo "  Version : ${VERSION:-<unchanged>}"
  echo "  Message : ${MESSAGE:-<auto>}"
  echo "========================================"

  log "Processing package [$PKG]"
  log "PKG_PATH exists: $(ls -d "$PKG_PATH" 2>/dev/null || echo NO)"
  pushd "$PKG_PATH" >/dev/null

  CURRENT_BRANCH=$(git branch --show-current)
  
  [[ "$CURRENT_BRANCH" != "$MONOREPO_DEFAULT_BRANCH" ]] && {
    echo "‚ùå Not on default branch ($MONOREPO_DEFAULT_BRANCH)"
    exit 1
  }

  # Detect changes inside submodule properly
  CHANGED_FILES="$(git status --porcelain)"
  log "CHANGED_FILES raw:"
  printf '%s\n' "$CHANGED_FILES" | sed 's/^/  > /'

  if [[ -n "$CHANGED_FILES" ]]; then
      echo "‚ÑπÔ∏è  Changes detected in $PKG"
      log "Entered submodule [$PKG]"
      log "Current branch: $(git branch --show-current)"
      log "Git status porcelain:"

      # Stage everything
      run git add .

      # --------------------------
      # Auto bump version if not provided
      # --------------------------
      if [[ -z "$VERSION" ]]; then
          CURRENT_VERSION="$(latest_tag)"
          BUMP_TYPE="$(detect_bump)"
          VERSION="$(bump_version "$CURRENT_VERSION" "$BUMP_TYPE")"

          log "Auto version bump:"
          log "  Current: $CURRENT_VERSION"
          log "  Bump:    $BUMP_TYPE"
          log "  Next:    $VERSION"
      fi

      # Update composer.json version only if it differs
      if [[ -n "$VERSION" && -f composer.json ]]; then
          CURRENT_JSON_VERSION="$(jq -r '.version // empty' composer.json)"

          if [[ "$CURRENT_JSON_VERSION" != "$VERSION" ]]; then
              log "Updating composer.json version: $CURRENT_JSON_VERSION ‚Üí $VERSION"

              TMP_JSON="$(mktemp)"
              trap 'rm -f "$TMP_JSON"' EXIT
              run jq --arg v "$VERSION" '.version = $v' composer.json > "$TMP_JSON"
              run mv "$TMP_JSON" composer.json
              trap - EXIT

              run git add composer.json
          else
              log "composer.json version already $VERSION ‚Äî no update needed"
          fi
      fi


      COMMIT_MSG="${MESSAGE:-"chore($PKG): release $VERSION"}"
      run git commit -m "$COMMIT_MSG"
      run git push origin "$CURRENT_BRANCH"
  else
      echo "‚ÑπÔ∏è  No changes to commit for $PKG"
  fi

  popd >/dev/null

  UPDATED_SUBMODULES+=("$PKG")
  # Store for later publishing
  TO_PUBLISH["$PKG"]="$VERSION"
done

# --------------------------
# Commit updated submodule pointers and bump root metadata
# --------------------------
METADATA_FILE="composer.json"  # root-level metadata

if [[ ${#UPDATED_SUBMODULES[@]} -gt 0 ]]; then
  echo ""
  echo "üì¶ Updating submodule pointers and root metadata..."

  declare -A SUBMODULE_VERSIONS

  # Stage updated submodules and collect their versions
  for pkg in "${UPDATED_SUBMODULES[@]}"; do
    run git add "packages/$pkg"
    SUBMODULE_VERSIONS["$pkg"]="$(git -C "packages/$pkg" describe --tags --abbrev=0 2>/dev/null || echo "unknown")"
  done

  # --------------------------
  # Bump root metapackage version ONLY
  # --------------------------
  if [[ ${#UPDATED_SUBMODULES[@]} -gt 0 && -f "$METADATA_FILE" ]]; then
    echo "üì¶ Bumping root metapackage version..."

    CURRENT_META_VERSION="$(jq -r '.version // empty' "$METADATA_FILE")"
    [[ -z "$CURRENT_META_VERSION" ]] && CURRENT_META_VERSION="0.0.0"

    META_BUMP_TYPE="$(detect_bump)"
    NEXT_META_VERSION="$(bump_version "$CURRENT_META_VERSION" "$META_BUMP_TYPE")"

    log "Root version bump:"
    log "  Current: $CURRENT_META_VERSION"
    log "  Bump:    $META_BUMP_TYPE"
    log "  Next:    $NEXT_META_VERSION"

    if is_dry_run; then
      echo "üü° DRY-RUN: Update root composer.json version ‚Üí $NEXT_META_VERSION"
    else
      TMP_JSON="$(mktemp)"
      jq --arg v "$NEXT_META_VERSION" '.version = $v' "$METADATA_FILE" > "$TMP_JSON"
      mv "$TMP_JSON" "$METADATA_FILE"
      git add "$METADATA_FILE"
    fi
  fi

  # Construct descriptive commit message
  COMMIT_MSG="chore(release): update submodule pointers"
  for pkg in "${UPDATED_SUBMODULES[@]}"; do
    COMMIT_MSG+=" | $pkg@${SUBMODULE_VERSIONS[$pkg]}"
  done

  # Commit everything if there are staged changes
  if ! git diff --cached --quiet; then
    run git commit -m "$COMMIT_MSG"
    ROOT_BRANCH=$(git symbolic-ref --quiet --short HEAD || echo "$MONOREPO_DEFAULT_BRANCH")
    run git push origin "$ROOT_BRANCH"
  else
    echo "‚ÑπÔ∏è  Monorepo pointers and root metadata already up-to-date"
  fi
fi

# --------------------------
# Publish all packages
# --------------------------
for pkg in "${!TO_PUBLISH[@]}"; do
    ver="${TO_PUBLISH[$pkg]}"
    ./publish.sh "$pkg" "$ver" "$DRY_RUN"
done


echo ""
if is_dry_run; then
  echo "‚úÖ Release finished (dry-run)"
else
  echo "‚úÖ Release finished"
fi
